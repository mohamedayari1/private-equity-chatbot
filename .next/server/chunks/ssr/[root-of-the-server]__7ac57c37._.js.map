{"version":3,"sources":["../../../../components/minimal-components/minimalChat.tsx/__nextjs-internal-proxy.mjs","../../../../app/%28chat%29/page.tsx","../../../../node_modules/clsx/dist/clsx.mjs","../../../../lib/errors.ts","../../../../node_modules/nanoid/index.js","../../../../node_modules/nanoid/url-alphabet/index.js","../../../../lib/utils.ts"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const Chat = registerClientReference(\n    function() { throw new Error(\"Attempted to call Chat() from the server but Chat is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/minimal-components/minimalChat.tsx\",\n    \"Chat\",\n);\n","// import { Chat } from '@/components/chat';\nimport { Chat } from '@/components/minimal-components/minimalChat';\nimport { generateUUID } from '@/lib/utils';\n\nexport default async function Page() {\n  const id = generateUUID();\n\n  return (\n    <>\n      {/* <Chat\n        key={id}\n        id={id}\n        initialMessages={[]}\n        initialChatModel={DEFAULT_CHAT_MODEL}\n        initialVisibilityType=\"private\"\n        isReadonly={false}\n        autoResume={false}\n      /> */}\n    <Chat />;\n\n    </>\n  );\n}\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","export type ErrorType =\n  | 'bad_request'\n  | 'unauthorized'\n  | 'forbidden'\n  | 'not_found'\n  | 'rate_limit'\n  | 'offline';\n\nexport type Surface =\n  | 'chat'\n  | 'auth'\n  | 'api'\n  | 'stream'\n  | 'database'\n  | 'history'\n  | 'vote'\n  | 'document'\n  | 'suggestions';\n\nexport type ErrorCode = `${ErrorType}:${Surface}`;\n\nexport type ErrorVisibility = 'response' | 'log' | 'none';\n\nexport const visibilityBySurface: Record<Surface, ErrorVisibility> = {\n  database: 'log',\n  chat: 'response',\n  auth: 'response',\n  stream: 'response',\n  api: 'response',\n  history: 'response',\n  vote: 'response',\n  document: 'response',\n  suggestions: 'response',\n};\n\nexport class ChatSDKError extends Error {\n  public type: ErrorType;\n  public surface: Surface;\n  public statusCode: number;\n\n  constructor(errorCode: ErrorCode, cause?: string) {\n    super();\n\n    const [type, surface] = errorCode.split(':');\n\n    this.type = type as ErrorType;\n    this.cause = cause;\n    this.surface = surface as Surface;\n    this.message = getMessageByErrorCode(errorCode);\n    this.statusCode = getStatusCodeByType(this.type);\n  }\n\n  public toResponse() {\n    const code: ErrorCode = `${this.type}:${this.surface}`;\n    const visibility = visibilityBySurface[this.surface];\n\n    const { message, cause, statusCode } = this;\n\n    if (visibility === 'log') {\n      console.error({\n        code,\n        message,\n        cause,\n      });\n\n      return Response.json(\n        { code: '', message: 'Something went wrong. Please try again later.' },\n        { status: statusCode },\n      );\n    }\n\n    return Response.json({ code, message, cause }, { status: statusCode });\n  }\n}\n\nexport function getMessageByErrorCode(errorCode: ErrorCode): string {\n  if (errorCode.includes('database')) {\n    return 'An error occurred while executing a database query.';\n  }\n\n  switch (errorCode) {\n    case 'bad_request:api':\n      return \"The request couldn't be processed. Please check your input and try again.\";\n\n    case 'unauthorized:auth':\n      return 'You need to sign in before continuing.';\n    case 'forbidden:auth':\n      return 'Your account does not have access to this feature.';\n\n    case 'rate_limit:chat':\n      return 'You have exceeded your maximum number of messages for the day. Please try again later.';\n    case 'not_found:chat':\n      return 'The requested chat was not found. Please check the chat ID and try again.';\n    case 'forbidden:chat':\n      return 'This chat belongs to another user. Please check the chat ID and try again.';\n    case 'unauthorized:chat':\n      return 'You need to sign in to view this chat. Please sign in and try again.';\n    case 'offline:chat':\n      return \"We're having trouble sending your message. Please check your internet connection and try again.\";\n\n    case 'not_found:document':\n      return 'The requested document was not found. Please check the document ID and try again.';\n    case 'forbidden:document':\n      return 'This document belongs to another user. Please check the document ID and try again.';\n    case 'unauthorized:document':\n      return 'You need to sign in to view this document. Please sign in and try again.';\n    case 'bad_request:document':\n      return 'The request to create or update the document was invalid. Please check your input and try again.';\n\n    default:\n      return 'Something went wrong. Please try again later.';\n  }\n}\n\nfunction getStatusCodeByType(type: ErrorType) {\n  switch (type) {\n    case 'bad_request':\n      return 400;\n    case 'unauthorized':\n      return 401;\n    case 'forbidden':\n      return 403;\n    case 'not_found':\n      return 404;\n    case 'rate_limit':\n      return 429;\n    case 'offline':\n      return 503;\n    default:\n      return 500;\n  }\n}\n","import { webcrypto as crypto } from 'node:crypto'\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nfunction fillPool(bytes) {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.getRandomValues(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.getRandomValues(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nexport function random(bytes) {\n  fillPool((bytes |= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nexport function customRandom(alphabet, defaultSize, getRandom) {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport function customAlphabet(alphabet, size = 21) {\n  return customRandom(alphabet, size, random)\n}\nexport function nanoid(size = 21) {\n  fillPool((size |= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += scopedUrlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","import type { DBMessage, Document } from \"@/lib/db/schema\";\nimport type {\n  CoreAssistantMessage,\n  CoreToolMessage,\n  UIMessage,\n  UIMessagePart,\n} from \"ai\";\nimport { type ClassValue, clsx } from \"clsx\";\nimport { formatISO } from \"date-fns\";\nimport { twMerge } from \"tailwind-merge\";\nimport { ChatSDKError, type ErrorCode } from \"./errors\";\nimport type { ChatMessage, ChatTools, CustomUIDataTypes } from \"./types\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport const fetcher = async (url: string) => {\n  const response = await fetch(url);\n\n  if (!response.ok) {\n    const { code, cause } = await response.json();\n    throw new ChatSDKError(code as ErrorCode, cause);\n  }\n\n  return response.json();\n};\n\nexport async function fetchWithErrorHandlers(\n  input: RequestInfo | URL,\n  init?: RequestInit,\n) {\n  try {\n    const response = await fetch(input, init);\n\n    if (!response.ok) {\n      const { code, cause } = await response.json();\n      throw new ChatSDKError(code as ErrorCode, cause);\n    }\n\n    return response;\n  } catch (error: unknown) {\n    if (typeof navigator !== \"undefined\" && !navigator.onLine) {\n      throw new ChatSDKError(\"offline:chat\");\n    }\n\n    throw error;\n  }\n}\n\nexport function getLocalStorage(key: string) {\n  if (typeof window !== \"undefined\") {\n    return JSON.parse(localStorage.getItem(key) || \"[]\");\n  }\n  return [];\n}\n\nimport { nanoid } from \"nanoid\";\n\nexport function generateUUID(): string {\n  return nanoid();\n}\n\ntype ResponseMessageWithoutId = CoreToolMessage | CoreAssistantMessage;\ntype ResponseMessage = ResponseMessageWithoutId & { id: string };\n\nexport function getMostRecentUserMessage(messages: Array<UIMessage>) {\n  const userMessages = messages.filter((message) => message.role === \"user\");\n  return userMessages.at(-1);\n}\n\nexport function getDocumentTimestampByIndex(\n  documents: Array<Document>,\n  index: number,\n) {\n  if (!documents) return new Date();\n  if (index > documents.length) return new Date();\n\n  return documents[index].createdAt;\n}\n\nexport function getTrailingMessageId({\n  messages,\n}: {\n  messages: Array<ResponseMessage>;\n}): string | null {\n  const trailingMessage = messages.at(-1);\n\n  if (!trailingMessage) return null;\n\n  return trailingMessage.id;\n}\n\nexport function sanitizeText(text: string) {\n  return text.replace(\"<has_function_call>\", \"\");\n}\n\nexport function convertToUIMessages(messages: DBMessage[]): ChatMessage[] {\n  return messages.map((message) => ({\n    id: message.id,\n    role: message.role as \"user\" | \"assistant\" | \"system\",\n    parts: message.parts as UIMessagePart<CustomUIDataTypes, ChatTools>[],\n    metadata: {\n      createdAt: formatISO(message.createdAt),\n    },\n  }));\n}\n\nexport function getTextFromMessage(message: ChatMessage): string {\n  return message.parts\n    .filter((part) => part.type === \"text\")\n    .map((part) => part.text)\n    .join(\"\");\n}\n"],"names":[],"mappings":"0aAEO,IAAM,EAAO,CAAA,EAAA,AADpB,EAAA,CAAA,CAAA,OACoB,uBAAA,AAAuB,EACvC,WAAa,MAAM,AAAI,MAAM,sNAAwN,EACrP,8EACA,oDAHG,IAAM,EAAO,CAAA,EADpB,AACoB,EADpB,CAAA,CAAA,OACoB,uBAAA,AAAuB,EACvC,WAAa,MAAM,AAAI,MAAM,sNAAwN,EACrP,0DACA,+FIDA,EAAM,kBHHV,EAAA,EAAA,CAAA,CAAA,OGDA,EAAA,EAAA,CAAA,CAAA,OHIe,eAAe,IAG5B,OG+BK,AEsBE,SFtBO,AAAO,EAAO,EAAE,MAjCd,IAkCN,CAlCW,EAkCH,EAjCd,CAAC,GAAQ,EAAK,MAAM,CAAG,GACzB,EAAO,EADyB,KAClB,WAAW,CAJA,IAIC,GAC1B,EAAA,GADkC,MAC5B,CAAC,eAAe,CAAC,GACvB,EAAa,GACJ,EAAa,EAAQ,EAAK,MAAM,EAAE,CAC3C,EAAA,SAAM,CAAC,eAAe,CAAC,GACvB,EAAa,GAEf,GAAc,EA2Bd,IAAK,IAAI,EAAI,EAAa,EAAM,EAAI,EAAY,ICxChD,ADwCqD,AAC7C,kEAAiB,CAAW,GAAV,CAAI,CAAC,EAAE,CAGnC,AAHyC,IHlCrC,CAAA,EAAA,EAAA,IAAA,EAAA,EAAA,QAAA,CAAA,WAUA,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,IAAI,CAAA,CAAA,GAAG,MAIZ","ignoreList":[0,2,4,5]}