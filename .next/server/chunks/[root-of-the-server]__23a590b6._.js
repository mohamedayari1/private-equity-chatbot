module.exports = {

"[project]/.next-internal/server/app/(chat)/api/history/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-experimental.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-experimental.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-experimental.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-experimental.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@opentelemetry/api", () => require("@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-experimental.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-experimental.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-experimental.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-experimental.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/node:crypto [external] (node:crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/node:buffer [external] (node:buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:buffer", () => require("node:buffer"));

module.exports = mod;
}}),
"[externals]/node:crypto [external] (node:crypto, cjs) <export randomFillSync as default>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["randomFillSync"])
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
}}),
"[externals]/node:util [external] (node:util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}}),
"[project]/lib/db/queries.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// import 'server-only';
// import {
//   and,
//   asc,
//   count,
//   desc,
//   eq,
//   gt,
//   gte,
//   inArray,
//   lt,
//   type SQL,
// } from 'drizzle-orm';
// import { drizzle } from 'drizzle-orm/postgres-js';
// import postgres from 'postgres';
// import {
//   user,
//   chat,
//   type User,
//   document,
//   type Suggestion,
//   suggestion,
//   message,
//   vote,
//   type DBMessage,
//   type Chat,
//   stream,
// } from './schema';
// import type { ArtifactKind } from '@/components/artifact';
// import { generateUUID } from '../utils';
// import { generateHashedPassword } from './utils';
// import type { VisibilityType } from '@/components/visibility-selector';
// import { ChatSDKError } from '../errors';
// // Optionally, if not using email/pass login, you can
// // use the Drizzle adapter for Auth.js / NextAuth
// // https://authjs.dev/reference/adapter/drizzle
// // biome-ignore lint: Forbidden non-null assertion.
// const client = postgres(process.env.POSTGRES_URL!);
// const db = drizzle(client);
// export async function getUser(email: string): Promise<Array<User>> {
//   try {
//     return await db.select().from(user).where(eq(user.email, email));
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get user by email',
//     );
//   }
// }
// export async function createUser(email: string, password: string) {
//   const hashedPassword = generateHashedPassword(password);
//   try {
//     return await db.insert(user).values({ email, password: hashedPassword });
//   } catch (error) {
//     throw new ChatSDKError('bad_request:database', 'Failed to create user');
//   }
// }
// export async function createGuestUser() {
//   const email = `guest-${Date.now()}`;
//   const password = generateHashedPassword(generateUUID());
//   try {
//     return await db.insert(user).values({ email, password }).returning({
//       id: user.id,
//       email: user.email,
//     });
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to create guest user',
//     );
//   }
// }
// export async function saveChat({
//   id,
//   userId,
//   title,
//   visibility,
// }: {
//   id: string;
//   userId: string;
//   title: string;
//   visibility: VisibilityType;
// }) {
//   try {
//     return await db.insert(chat).values({
//       id,
//       createdAt: new Date(),
//       userId,
//       title,
//       visibility,
//     });
//   } catch (error) {
//     throw new ChatSDKError('bad_request:database', 'Failed to save chat');
//   }
// }
// export async function deleteChatById({ id }: { id: string }) {
//   try {
//     await db.delete(vote).where(eq(vote.chatId, id));
//     await db.delete(message).where(eq(message.chatId, id));
//     await db.delete(stream).where(eq(stream.chatId, id));
//     const [chatsDeleted] = await db
//       .delete(chat)
//       .where(eq(chat.id, id))
//       .returning();
//     return chatsDeleted;
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to delete chat by id',
//     );
//   }
// }
// export async function getChatsByUserId({
//   id,
//   limit,
//   startingAfter,
//   endingBefore,
// }: {
//   id: string;
//   limit: number;
//   startingAfter: string | null;
//   endingBefore: string | null;
// }) {
//   try {
//     const extendedLimit = limit + 1;
//     const query = (whereCondition?: SQL<any>) =>
//       db
//         .select()
//         .from(chat)
//         .where(
//           whereCondition
//             ? and(whereCondition, eq(chat.userId, id))
//             : eq(chat.userId, id),
//         )
//         .orderBy(desc(chat.createdAt))
//         .limit(extendedLimit);
//     let filteredChats: Array<Chat> = [];
//     if (startingAfter) {
//       const [selectedChat] = await db
//         .select()
//         .from(chat)
//         .where(eq(chat.id, startingAfter))
//         .limit(1);
//       if (!selectedChat) {
//         throw new ChatSDKError(
//           'not_found:database',
//           `Chat with id ${startingAfter} not found`,
//         );
//       }
//       filteredChats = await query(gt(chat.createdAt, selectedChat.createdAt));
//     } else if (endingBefore) {
//       const [selectedChat] = await db
//         .select()
//         .from(chat)
//         .where(eq(chat.id, endingBefore))
//         .limit(1);
//       if (!selectedChat) {
//         throw new ChatSDKError(
//           'not_found:database',
//           `Chat with id ${endingBefore} not found`,
//         );
//       }
//       filteredChats = await query(lt(chat.createdAt, selectedChat.createdAt));
//     } else {
//       filteredChats = await query();
//     }
//     const hasMore = filteredChats.length > limit;
//     return {
//       chats: hasMore ? filteredChats.slice(0, limit) : filteredChats,
//       hasMore,
//     };
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get chats by user id',
//     );
//   }
// }
// export async function getChatById({ id }: { id: string }) {
//   try {
//     const [selectedChat] = await db.select().from(chat).where(eq(chat.id, id));
//     return selectedChat;
//   } catch (error) {
//     throw new ChatSDKError('bad_request:database', 'Failed to get chat by id');
//   }
// }
// export async function saveMessages({
//   messages,
// }: {
//   messages: Array<DBMessage>;
// }) {
//   try {
//     return await db.insert(message).values(messages);
//   } catch (error) {
//     throw new ChatSDKError('bad_request:database', 'Failed to save messages');
//   }
// }
// export async function getMessagesByChatId({ id }: { id: string }) {
//   try {
//     return await db
//       .select()
//       .from(message)
//       .where(eq(message.chatId, id))
//       .orderBy(asc(message.createdAt));
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get messages by chat id',
//     );
//   }
// }
// export async function voteMessage({
//   chatId,
//   messageId,
//   type,
// }: {
//   chatId: string;
//   messageId: string;
//   type: 'up' | 'down';
// }) {
//   try {
//     const [existingVote] = await db
//       .select()
//       .from(vote)
//       .where(and(eq(vote.messageId, messageId)));
//     if (existingVote) {
//       return await db
//         .update(vote)
//         .set({ isUpvoted: type === 'up' })
//         .where(and(eq(vote.messageId, messageId), eq(vote.chatId, chatId)));
//     }
//     return await db.insert(vote).values({
//       chatId,
//       messageId,
//       isUpvoted: type === 'up',
//     });
//   } catch (error) {
//     throw new ChatSDKError('bad_request:database', 'Failed to vote message');
//   }
// }
// export async function getVotesByChatId({ id }: { id: string }) {
//   try {
//     return await db.select().from(vote).where(eq(vote.chatId, id));
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get votes by chat id',
//     );
//   }
// }
// export async function saveDocument({
//   id,
//   title,
//   kind,
//   content,
//   userId,
// }: {
//   id: string;
//   title: string;
//   kind: ArtifactKind;
//   content: string;
//   userId: string;
// }) {
//   try {
//     return await db
//       .insert(document)
//       .values({
//         id,
//         title,
//         kind,
//         content,
//         userId,
//         createdAt: new Date(),
//       })
//       .returning();
//   } catch (error) {
//     throw new ChatSDKError('bad_request:database', 'Failed to save document');
//   }
// }
// export async function getDocumentsById({ id }: { id: string }) {
//   try {
//     const documents = await db
//       .select()
//       .from(document)
//       .where(eq(document.id, id))
//       .orderBy(asc(document.createdAt));
//     return documents;
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get documents by id',
//     );
//   }
// }
// export async function getDocumentById({ id }: { id: string }) {
//   try {
//     const [selectedDocument] = await db
//       .select()
//       .from(document)
//       .where(eq(document.id, id))
//       .orderBy(desc(document.createdAt));
//     return selectedDocument;
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get document by id',
//     );
//   }
// }
// export async function deleteDocumentsByIdAfterTimestamp({
//   id,
//   timestamp,
// }: {
//   id: string;
//   timestamp: Date;
// }) {
//   try {
//     await db
//       .delete(suggestion)
//       .where(
//         and(
//           eq(suggestion.documentId, id),
//           gt(suggestion.documentCreatedAt, timestamp),
//         ),
//       );
//     return await db
//       .delete(document)
//       .where(and(eq(document.id, id), gt(document.createdAt, timestamp)))
//       .returning();
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to delete documents by id after timestamp',
//     );
//   }
// }
// export async function saveSuggestions({
//   suggestions,
// }: {
//   suggestions: Array<Suggestion>;
// }) {
//   try {
//     return await db.insert(suggestion).values(suggestions);
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to save suggestions',
//     );
//   }
// }
// export async function getSuggestionsByDocumentId({
//   documentId,
// }: {
//   documentId: string;
// }) {
//   try {
//     return await db
//       .select()
//       .from(suggestion)
//       .where(and(eq(suggestion.documentId, documentId)));
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get suggestions by document id',
//     );
//   }
// }
// export async function getMessageById({ id }: { id: string }) {
//   try {
//     return await db.select().from(message).where(eq(message.id, id));
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get message by id',
//     );
//   }
// }
// export async function deleteMessagesByChatIdAfterTimestamp({
//   chatId,
//   timestamp,
// }: {
//   chatId: string;
//   timestamp: Date;
// }) {
//   try {
//     const messagesToDelete = await db
//       .select({ id: message.id })
//       .from(message)
//       .where(
//         and(eq(message.chatId, chatId), gte(message.createdAt, timestamp)),
//       );
//     const messageIds = messagesToDelete.map((message) => message.id);
//     if (messageIds.length > 0) {
//       await db
//         .delete(vote)
//         .where(
//           and(eq(vote.chatId, chatId), inArray(vote.messageId, messageIds)),
//         );
//       return await db
//         .delete(message)
//         .where(
//           and(eq(message.chatId, chatId), inArray(message.id, messageIds)),
//         );
//     }
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to delete messages by chat id after timestamp',
//     );
//   }
// }
// export async function updateChatVisiblityById({
//   chatId,
//   visibility,
// }: {
//   chatId: string;
//   visibility: 'private' | 'public';
// }) {
//   try {
//     return await db.update(chat).set({ visibility }).where(eq(chat.id, chatId));
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to update chat visibility by id',
//     );
//   }
// }
// export async function getMessageCountByUserId({
//   id,
//   differenceInHours,
// }: { id: string; differenceInHours: number }) {
//   try {
//     const twentyFourHoursAgo = new Date(
//       Date.now() - differenceInHours * 60 * 60 * 1000,
//     );
//     const [stats] = await db
//       .select({ count: count(message.id) })
//       .from(message)
//       .innerJoin(chat, eq(message.chatId, chat.id))
//       .where(
//         and(
//           eq(chat.userId, id),
//           gte(message.createdAt, twentyFourHoursAgo),
//           eq(message.role, 'user'),
//         ),
//       )
//       .execute();
//     return stats?.count ?? 0;
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get message count by user id',
//     );
//   }
// }
// export async function createStreamId({
//   streamId,
//   chatId,
// }: {
//   streamId: string;
//   chatId: string;
// }) {
//   try {
//     await db
//       .insert(stream)
//       .values({ id: streamId, chatId, createdAt: new Date() });
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to create stream id',
//     );
//   }
// }
// export async function getStreamIdsByChatId({ chatId }: { chatId: string }) {
//   try {
//     const streamIds = await db
//       .select({ id: stream.id })
//       .from(stream)
//       .where(eq(stream.chatId, chatId))
//       .orderBy(asc(stream.createdAt))
//       .execute();
//     return streamIds.map(({ id }) => id);
//   } catch (error) {
//     throw new ChatSDKError(
//       'bad_request:database',
//       'Failed to get stream ids by chat id',
//     );
//   }
// }
// Stub functions for deployment without database
__turbopack_context__.s({
    "createGuestUser": (()=>createGuestUser),
    "createStreamId": (()=>createStreamId),
    "createUser": (()=>createUser),
    "deleteChatById": (()=>deleteChatById),
    "deleteDocumentsByIdAfterTimestamp": (()=>deleteDocumentsByIdAfterTimestamp),
    "deleteMessagesByChatIdAfterTimestamp": (()=>deleteMessagesByChatIdAfterTimestamp),
    "getChatById": (()=>getChatById),
    "getChatsByUserId": (()=>getChatsByUserId),
    "getDocumentById": (()=>getDocumentById),
    "getDocumentsById": (()=>getDocumentsById),
    "getMessageById": (()=>getMessageById),
    "getMessageCountByUserId": (()=>getMessageCountByUserId),
    "getMessagesByChatId": (()=>getMessagesByChatId),
    "getStreamIdsByChatId": (()=>getStreamIdsByChatId),
    "getSuggestionsByDocumentId": (()=>getSuggestionsByDocumentId),
    "getUser": (()=>getUser),
    "getVotesByChatId": (()=>getVotesByChatId),
    "saveChat": (()=>saveChat),
    "saveDocument": (()=>saveDocument),
    "saveMessages": (()=>saveMessages),
    "saveSuggestions": (()=>saveSuggestions),
    "updateChatVisiblityById": (()=>updateChatVisiblityById),
    "voteMessage": (()=>voteMessage)
});
async function getUser(email) {
    // Stub function - returns empty array to indicate no user found
    return [];
}
async function createUser(email, password) {
    // Stub function - does nothing for now
    console.log('Stub: createUser called with email:', email);
    return null;
}
async function createGuestUser() {
    // Stub function - returns mock guest user
    return [
        {
            id: 'guest-123',
            email: 'guest@example.com'
        }
    ];
}
async function saveChat({ id, userId, title, visibility }) {
    // Stub function - does nothing for now
    console.log('Stub: saveChat called with id:', id);
    return null;
}
async function deleteChatById({ id }) {
    // Stub function - does nothing for now
    console.log('Stub: deleteChatById called with id:', id);
    return null;
}
async function getChatsByUserId({ id, limit, startingAfter, endingBefore }) {
    // Stub function - returns empty chats
    return {
        chats: [],
        hasMore: false
    };
}
async function getChatById({ id }) {
    // Stub function - returns null
    return null;
}
async function saveMessages({ messages }) {
    // Stub function - does nothing for now
    console.log('Stub: saveMessages called with', messages.length, 'messages');
    return null;
}
async function getMessagesByChatId({ id }) {
    // Stub function - returns empty array
    return [];
}
async function voteMessage({ chatId, messageId, type }) {
    // Stub function - does nothing for now
    console.log('Stub: voteMessage called with type:', type);
    return null;
}
async function getVotesByChatId({ id }) {
    // Stub function - returns empty array
    return [];
}
async function saveDocument({ id, title, kind, content, userId }) {
    // Stub function - does nothing for now
    console.log('Stub: saveDocument called with id:', id);
    return null;
}
async function getDocumentsById({ id }) {
    // Stub function - returns empty array
    return [];
}
async function getDocumentById({ id }) {
    // Stub function - returns null
    return null;
}
async function deleteDocumentsByIdAfterTimestamp({ id, timestamp }) {
    // Stub function - does nothing for now
    console.log('Stub: deleteDocumentsByIdAfterTimestamp called with id:', id);
    return null;
}
async function saveSuggestions({ suggestions }) {
    // Stub function - does nothing for now
    console.log('Stub: saveSuggestions called with', suggestions.length, 'suggestions');
    return null;
}
async function getSuggestionsByDocumentId({ documentId }) {
    // Stub function - returns empty array
    return [];
}
async function getMessageById({ id }) {
    // Stub function - returns empty array
    return [];
}
async function deleteMessagesByChatIdAfterTimestamp({ chatId, timestamp }) {
    // Stub function - does nothing for now
    console.log('Stub: deleteMessagesByChatIdAfterTimestamp called with chatId:', chatId);
    return null;
}
async function updateChatVisiblityById({ chatId, visibility }) {
    // Stub function - does nothing for now
    console.log('Stub: updateChatVisiblityById called with visibility:', visibility);
    return null;
}
async function getMessageCountByUserId({ id, differenceInHours }) {
    // Stub function - returns 0
    return 0;
}
async function createStreamId({ streamId, chatId }) {
    // Stub function - does nothing for now
    console.log('Stub: createStreamId called with streamId:', streamId);
    return null;
}
async function getStreamIdsByChatId({ chatId }) {
    // Stub function - returns empty array
    return [];
}
}}),
"[project]/app/(auth)/auth.config.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "authConfig": (()=>authConfig)
});
const authConfig = {
    pages: {
        signIn: '/login',
        newUser: '/'
    },
    providers: [],
    callbacks: {}
};
}}),
"[project]/lib/db/utils.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "generateDummyPassword": (()=>generateDummyPassword),
    "generateHashedPassword": (()=>generateHashedPassword)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/provider-utils/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcrypt$2d$ts$2f$dist$2f$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bcrypt-ts/dist/node.mjs [app-route] (ecmascript)");
;
;
function generateHashedPassword(password) {
    const salt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcrypt$2d$ts$2f$dist$2f$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["genSaltSync"])(10);
    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcrypt$2d$ts$2f$dist$2f$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSync"])(password, salt);
    return hash;
}
function generateDummyPassword() {
    const password = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["generateId"])();
    const hashedPassword = generateHashedPassword(password);
    return hashedPassword;
}
}}),
"[project]/lib/constants.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DUMMY_PASSWORD": (()=>DUMMY_PASSWORD),
    "guestRegex": (()=>guestRegex),
    "isDevelopmentEnvironment": (()=>isDevelopmentEnvironment),
    "isProductionEnvironment": (()=>isProductionEnvironment),
    "isTestEnvironment": (()=>isTestEnvironment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db/utils.ts [app-route] (ecmascript)");
;
const isProductionEnvironment = ("TURBOPACK compile-time value", "development") === 'production';
const isDevelopmentEnvironment = ("TURBOPACK compile-time value", "development") === 'development';
const isTestEnvironment = Boolean(process.env.PLAYWRIGHT_TEST_BASE_URL || process.env.PLAYWRIGHT || process.env.CI_PLAYWRIGHT);
const guestRegex = /^guest-\d+$/;
const DUMMY_PASSWORD = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateDummyPassword"])();
}}),
"[project]/app/(auth)/auth.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET),
    "POST": (()=>POST),
    "auth": (()=>auth),
    "signIn": (()=>signIn),
    "signOut": (()=>signOut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcrypt$2d$ts$2f$dist$2f$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bcrypt-ts/dist/node.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/providers/credentials.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth/core/providers/credentials.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db/queries.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f28$auth$292f$auth$2e$config$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/app/(auth)/auth.config.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$constants$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/constants.ts [app-route] (ecmascript)");
;
;
;
;
;
;
const { handlers: { GET, POST }, auth, signIn, signOut } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])({
    ...__TURBOPACK__imported__module__$5b$project$5d2f$app$2f28$auth$292f$auth$2e$config$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authConfig"],
    providers: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
            credentials: {},
            async authorize ({ email, password }) {
                const users = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUser"])(email);
                if (users.length === 0) {
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcrypt$2d$ts$2f$dist$2f$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compare"])(password, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$constants$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DUMMY_PASSWORD"]);
                    return null;
                }
                const [user] = users;
                if (!user.password) {
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcrypt$2d$ts$2f$dist$2f$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compare"])(password, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$constants$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DUMMY_PASSWORD"]);
                    return null;
                }
                const passwordsMatch = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcrypt$2d$ts$2f$dist$2f$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compare"])(password, user.password);
                if (!passwordsMatch) return null;
                return {
                    ...user,
                    type: 'regular'
                };
            }
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
            id: 'guest',
            credentials: {},
            async authorize () {
                const [guestUser] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createGuestUser"])();
                return {
                    ...guestUser,
                    type: 'guest'
                };
            }
        })
    ],
    callbacks: {
        async jwt ({ token, user }) {
            if (user) {
                token.id = user.id;
                token.type = user.type;
            }
            return token;
        },
        async session ({ session, token }) {
            if (session.user) {
                session.user.id = token.id;
                session.user.type = token.type;
            }
            return session;
        }
    }
});
}}),
"[project]/lib/errors.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ChatSDKError": (()=>ChatSDKError),
    "getMessageByErrorCode": (()=>getMessageByErrorCode),
    "visibilityBySurface": (()=>visibilityBySurface)
});
const visibilityBySurface = {
    database: 'log',
    chat: 'response',
    auth: 'response',
    stream: 'response',
    api: 'response',
    history: 'response',
    vote: 'response',
    document: 'response',
    suggestions: 'response'
};
class ChatSDKError extends Error {
    type;
    surface;
    statusCode;
    constructor(errorCode, cause){
        super();
        const [type, surface] = errorCode.split(':');
        this.type = type;
        this.cause = cause;
        this.surface = surface;
        this.message = getMessageByErrorCode(errorCode);
        this.statusCode = getStatusCodeByType(this.type);
    }
    toResponse() {
        const code = `${this.type}:${this.surface}`;
        const visibility = visibilityBySurface[this.surface];
        const { message, cause, statusCode } = this;
        if (visibility === 'log') {
            console.error({
                code,
                message,
                cause
            });
            return Response.json({
                code: '',
                message: 'Something went wrong. Please try again later.'
            }, {
                status: statusCode
            });
        }
        return Response.json({
            code,
            message,
            cause
        }, {
            status: statusCode
        });
    }
}
function getMessageByErrorCode(errorCode) {
    if (errorCode.includes('database')) {
        return 'An error occurred while executing a database query.';
    }
    switch(errorCode){
        case 'bad_request:api':
            return "The request couldn't be processed. Please check your input and try again.";
        case 'unauthorized:auth':
            return 'You need to sign in before continuing.';
        case 'forbidden:auth':
            return 'Your account does not have access to this feature.';
        case 'rate_limit:chat':
            return 'You have exceeded your maximum number of messages for the day. Please try again later.';
        case 'not_found:chat':
            return 'The requested chat was not found. Please check the chat ID and try again.';
        case 'forbidden:chat':
            return 'This chat belongs to another user. Please check the chat ID and try again.';
        case 'unauthorized:chat':
            return 'You need to sign in to view this chat. Please sign in and try again.';
        case 'offline:chat':
            return "We're having trouble sending your message. Please check your internet connection and try again.";
        case 'not_found:document':
            return 'The requested document was not found. Please check the document ID and try again.';
        case 'forbidden:document':
            return 'This document belongs to another user. Please check the document ID and try again.';
        case 'unauthorized:document':
            return 'You need to sign in to view this document. Please sign in and try again.';
        case 'bad_request:document':
            return 'The request to create or update the document was invalid. Please check your input and try again.';
        default:
            return 'Something went wrong. Please try again later.';
    }
}
function getStatusCodeByType(type) {
    switch(type){
        case 'bad_request':
            return 400;
        case 'unauthorized':
            return 401;
        case 'forbidden':
            return 403;
        case 'not_found':
            return 404;
        case 'rate_limit':
            return 429;
        case 'offline':
            return 503;
        default:
            return 500;
    }
}
}}),
"[project]/app/(chat)/api/history/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f28$auth$292f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/app/(auth)/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db/queries.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$errors$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/errors.ts [app-route] (ecmascript)");
;
;
;
async function GET(request) {
    const { searchParams } = request.nextUrl;
    const limit = Number.parseInt(searchParams.get('limit') || '10');
    const startingAfter = searchParams.get('starting_after');
    const endingBefore = searchParams.get('ending_before');
    if (startingAfter && endingBefore) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$errors$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChatSDKError"]('bad_request:api', 'Only one of starting_after or ending_before can be provided.').toResponse();
    }
    const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$app$2f28$auth$292f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
    if (!session?.user) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$errors$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChatSDKError"]('unauthorized:chat').toResponse();
    }
    const chats = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getChatsByUserId"])({
        id: session.user.id,
        limit,
        startingAfter,
        endingBefore
    });
    return Response.json(chats);
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__23a590b6._.js.map